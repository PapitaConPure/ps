cargar dibujar con Funci√≥n()
  crear Lista mt
  repetir hh veces
    crear Lista fila
    repetir ww veces
      extender fila con "‚¨õ"
    fin
    extender mt con fila
  fin

  cargar pintar con Funci√≥n(p, car)
    cargar mt.(p.py).(p.px) con car
  fin

  usar jgs->paraCada(p => pintar(p, "üü¢"))

  si mt.(ch.py).(ch.px) es "üü¢"
    usar pintar(ch, "üî¥")
  sino
    usar pintar(ch, "üçí")
  fin

  usar pintar(jg, "üü°")

  devolver "**Puntos:** " + puntos + "\n" + mt.mapear(f => f.unir("")).unir("\n")
fin

cargar Cereza con Funci√≥n()
  cargar c con Registro px: dado(ww), py: dado(hh)
  si jg.px es c.px y jg.py es c.py
    cargar c.py con (jg.py es 0 y dado(1, hh)) o elegir(dado(0, jg.py), (jg.py es (hh - 1) y (hh - 1)) o dado(jg.py + 1, hh))
  fin
  devolver c
fin

cargar ww con 8
cargar hh con 6
cargar puntos con puntos o 0
cargar jg con jg o Registro largo: 3, px: (ww / 2).redondear(), py: (hh / 2).redondear()
cargar jgs con jgs o Lista
cargar ch con ch o Cereza()

leer texto opcional m en min√∫scula

cargar pjx con jg.px
cargar pjy con jg.py
sumar jg.px con (m=='d') - (m=='a')
sumar jg.py con (m=='s') - (m=='w')

si pjx no es jg.px o pjy no es jg.py
  si jgs.largo < jg.largo
    extender jgs con Registro px: pjx, py: pjy
  sino
    para i con 0 mientras i < (jgs.largo - 1) sumar i
      cargar jgs.(i).px con jgs.(i + 1).px
      cargar jgs.(i).py con jgs.(i + 1).py
    fin
  fin
  cargar jgs.(jgs.largo - 1).px con pjx
  cargar jgs.(jgs.largo - 1).py con pjy
fin

si jgs->alguno(p => p.px es jg.px y p.py es jg.py)
o jg.px < 0 o jg.px >= ww o jg.py < 0 o jg.py >= hh
  enviar "**Perdiste con un largo de: ** " + jg.largo
  borrar jg
  borrar jgs
  borrar puntos
  terminar
fin

si jg.px es ch.px y jg.py es ch.py
  sumar jg.largo
  sumar puntos
  borrar ch
  enviar dibujar()
sino
  guardar ch
  enviar dibujar()
fin

guardar jg
guardar jgs
guardar puntos
